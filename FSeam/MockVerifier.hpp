// MIT License

// Copyright (c) 2019 Quentin Balland
// Project : https://github.com/FreeYourSoul/FSeam 

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//
// Created by FyS on 27/06/17.
//

#ifndef FREESOULS_MOCKVERIFIER_HH
#define FREESOULS_MOCKVERIFIER_HH

#include <utility>
#include <string>
#include <functional>
#include <memory>
#include <iostream>
#include <map>
#include <any>

#define mock_return_value(funcName, className, ret)  #funcName,[](void *data) { static_cast<className *>(data)->funcName##_ReturnValue = ret;},true
#define check_arg_value(funcName, className, argName, check)  #funcName,[](std::any &data) { return std::any_cast<className>(data).funcName##_##argName##_ParamValue == check;}

namespace FSeam {


    /**
     * @brief TypeTraitsClass with a ClassName alias in order to get the name of the class to mock (used as key for the methods)
     * @note The typetraits specifications are generated by FSeam generator
     * @tparam T type to mock
     */
    template <typename T>
    struct TypeParseTraits {
        inline static const std::string ClassName = "Undefined";
    };

    /**
     * @brief basic structure that contains description and usage metadata of a mocked method
     */
    struct MethodCallVerifier {
        std::string _methodName;
        std::size_t _called = 0;
        std::function<void(void*)> _handler;
        std::vector<std::any> _calledData;
    };

    /**
     * @brief Called Comparators option used in verify in order to give more flexibility into the check possible via te verify option
     * @note To be used in order to check the number of time a method has been called 
     */
    struct VerifyCompare {
        explicit VerifyCompare(uint toCompare) : _toCompare(toCompare) {}
        bool compare(uint number) { return _toCompare == number; } 
        std::string expectStr(uint number) { return std::string("we expected exactly ") +
            std::to_string(_toCompare) + std::string(" method call but received ") + std::to_string(number); };
        int _toCompare = 0;
    };
    struct NeverCalled {
        bool compare(uint number) { return !number; } 
        std::string expectStr(uint number) { return std::string("we expected this method to never be called ") +
            std::to_string(_toCompare) + std::string(" but received ") + std::to_string(number); };
        int _toCompare = 0;
    };
    struct AtLeast {
        explicit AtLeast(uint toCompare) : _toCompare(toCompare) {}
        bool compare(uint number) { return _toCompare <= number; }
        std::string expectStr(uint number) { return std::string("we expected at least ") +
            std::to_string(_toCompare) + std::string(" method call but received ") + std::to_string(number); };
        uint _toCompare = 0;
    };
    struct AtMost {
        explicit AtMost(uint toCompare) : _toCompare(toCompare) {}
        bool compare(uint number) { return _toCompare >= number; }
        std::string expectStr(uint number) { return std::string("we expected at most ") +
            std::to_string(_toCompare) + std::string(" method call but received ") + std::to_string(number); };
        uint _toCompare = 0;
    };
    struct IsNot { // Todo: Improve is not to take a list of params to check agains instead of a single value
        explicit IsNot(uint toCompare) : _toCompare(toCompare) {}
        bool compare(uint number) { return _toCompare != number; } 
        std::string expectStr(uint number) { return std::string("we expected other value than ") +
            std::to_string(_toCompare) + std::string(" method call but received ") + std::to_string(number); };
        uint _toCompare = 0;
    };

    template <typename TypeTraitClass>
    struct isCalledComparator { static const bool v = false;  };
    template <> struct isCalledComparator<IsNot> { static const bool v = true; };
    template <> struct isCalledComparator<AtMost> { static const bool v = true; };
    template <> struct isCalledComparator<AtLeast> { static const bool v = true; };
    template <> struct isCalledComparator<NeverCalled> { static const bool v = true; };
    template <> struct isCalledComparator<VerifyCompare> { static const bool v = true; };

    /**
     * @brief Comparators option used in verify in order to give more flexibility into the check possible via te verify option
     * @note To be used in order to check the arguments of a method via the MockClassVerifier::verifyArg method
     */
    template <typename TypeToCompare>
    struct Eq {
        explicit Eq(TypeToCompare && toCompare) : _toCompare(std::forward<TypeToCompare>(toCompare)) {}
        bool compare(TypeToCompare && value) { return value == _toCompare; } 
        TypeToCompare _toCompare;
    };

    template <typename TypeToCompare>
    struct NotEq {
        explicit NotEq(TypeToCompare && toCompare) : _toCompare(std::forward<TypeToCompare>(toCompare)) {}
        bool compare(TypeToCompare && value) { return value != _toCompare; } 
        TypeToCompare _toCompare;
    };

    template <typename TypeToCompare, typename Predicate>
    struct CustomComparator {
        explicit CustomComparator(TypeToCompare && toCompare, Predicate && predicate) :
            _toCompare(std::forward<TypeToCompare>(toCompare)), _comparePredicate(std::forward<Predicate>(predicate)) {}
        bool compare(TypeToCompare && value) { 
            return _comparePredicate(std::forward<TypeToCompare>(value), std::forward<TypeToCompare>(_toCompare));
        } 
        TypeToCompare _toCompare;
        Predicate _comparePredicate;
    };

    /**
     * @brief Mocking class, it contains all mocked method / save all calls to methods
     * @details A mock verifier instance class is a class that acknowledge all utilisation (method calls) of the mocked class
     *          this class also contains the mocked method (dupped).
     * @todo improve the mocking class to take the arguments and compare them in a verify
     */
    class MockClassVerifier {
    public:
        MockClassVerifier(std::string className) : _className(std::move(className)) {}

        /**
         * @note This method should never be used by the client directly, it is a "FSeam generated" method only
         */
        void invokeDupedMethod(const std::string &methodName, void *arg = nullptr) {
            std::string key = _className + std::move(methodName);

            if (_verifiers.find(key) != _verifiers.end()) {
                if (auto dupedMethod = _verifiers.at(key)->_handler; dupedMethod)
                    dupedMethod(arg);
            }
        }

        /**
         * @note This method should never be used by the client directly, it is a "FSeam generated" method only
         */
        void methodCall(std::string methodName, std::any &&callingInfo) {
            std::shared_ptr<MethodCallVerifier> methodCallVerifier;
            std::string key = _className + methodName;

            if (_verifiers.find(key) != _verifiers.end())
                methodCallVerifier = _verifiers.at(key);
            else 
                methodCallVerifier = std::make_shared<MethodCallVerifier>();
            methodCallVerifier->_methodName = std::move(methodName);
            methodCallVerifier->_calledData.emplace_back(std::move(callingInfo));
            methodCallVerifier->_called = methodCallVerifier->_calledData.size();
            _verifiers[std::move(key)] = methodCallVerifier;
        }


        /**
         * @brief Verify arguments for a specified method (template specification on a FSeam generated structure representing
         *        a specific method for a mocked class)
         * @note The method is going to call the verify method, replacing the contentChecker with proper check, the purpose of
         *       this method is to be more user friendly than the low level one
         * 
         * @tparam ClassMethodIdentifier identifier structure generated by FSeam which represent a specific method of a specific class
         * @tparam Verifiers could be simple type (in this case the comparator FSeam::Eq is being called) or any Comparator,
         * @param verifiers comparator used in order to check the arguments of the method identified by ClassMethodIdentifier
         * @return true if the method has been called at least once, false otherwise
         */
        template <typename ClassMethodIdentifier, typename ...Verifiers>
        bool verifyArg(Verifiers ... verifiers);

        /**
         * @brief Dupe the specified method (template specification on a FSeam generated structure representing a specific
         *        method fora mocked class)
         * @note The method is going to call the dupeMethod method, replacing the handler managing the Data structure, 
         *       the purpose of this method is to be more user friendly than the low level one
         * 
         * @tparam ClassMethodIdentifier identifier structure generated by FSeam which represent a specific method of a specific class
         * @tparam Handler function type following the signature of the provided method pointed by ClassMethodIdentifier
         * @param handler 
         * @param isComposed if true, compose a new handler with the current one and the provided one,
         *                   if false, override the existing handler if any
         *                   set at false by default
         */
        template <typename ClassMethodIdentifier, typename Handler>
        void dupe(Handler handler, bool isComposed = false);

        /**
         * @brief 
         * 
         * @tparam ClassMethodIdentifier 
         * @tparam ReturnType 
         * @param ret 
         */
        template <typename ClassMethodIdentifier, typename ReturnType>
        void dupeReturn(ReturnType ret);

        /**
         * @brief This method make it possible to dupe a method in order to have it do what you want.
         *        This is a low level function that require the user to understand how the generated data struct
         *        containing the function call metadata works (as this is the argument given to the handler)
         * @note It is recommended to use the dupe<> method instead (API which is more user friendly) 
         *
         * @param className name of the class to mock
         * @param methodName method name to dupe
         * @param handler dupped method that takes the data structure pointer. This data structure is a struct 
         *         that contains all the data for the called method (arguments, return values)
         * @param isComposed if true, compose a new handler with the current one and the provided one,
         *         if false, override the existing handler if any. Set at false by default
         */
        void dupeMethod(std::string methodName, const std::function<void(void*)> &handler, bool isComposed = false) {
            auto methodCallVerifier = std::make_shared<MethodCallVerifier>();
            std::string key = _className + methodName;

            if (_verifiers.find(key) != _verifiers.end())
                methodCallVerifier = _verifiers.at(key);
            methodCallVerifier->_methodName = std::move(methodName);
            methodCallVerifier->_calledData.clear();
            methodCallVerifier->_called = methodCallVerifier->_calledData.size();
            if (isComposed && methodCallVerifier->_handler) {
                methodCallVerifier->_handler = [currentHandler = methodCallVerifier->_handler, handler](void *data){
                    currentHandler(data);
                    handler(data);
                };
            }
            else
                methodCallVerifier->_handler = handler;
            _verifiers[std::move(key)] = methodCallVerifier;
        }

        /**
         * @brief verify if the given method has been at least called once
         * @details will call verify with a passthrough predicate and a AtLeast(1) comparator
         * @note If a check on the arguments is needed, it is recommended to use the verifyArgs<> method instead
         *       (API which is more user friendly)
         * 
         * @param methodName method to check
         * @return true if the method has been called at least once, false otherwise
         */
        bool verify(std::string methodName) const {
            return verify(std::move(methodName), [](std::any &methodCallVerifier) { return true; }, AtLeast(1));
        }

        /**
         * @brief Verify if a method has been called under certain conditions (number of times)
         * @note This method is going to call its templated overload using a default contentChecker (no check) and
         *       either FSeam::VerifierComparator::VerifyComparator or FSeam::VerifierComparator::AtLeast as Comparator
         *       depending on the value of times
         *
         * @tparam ComparatorOrContentChecker can be an integer/a comparator/a predicate see argument for additional info
         * @param methodName method to verify
         * @param compOrContentChecker can be an int or a predicate for the count
         *         if set as a predicate it will be used in order to check if the method has been called following
         *           specific predicament (std::auto containing metadata of call) and check if atLeast(1) is found
         *         otherwhise a passthrough predicament is used (return true)
         *        =================
         *         if set with a positive integral value, check of times you verify that the mocked method has been called
         *           exactly the number of time provided (use the FSeam::VerifyComparator(compOrContentChecker)),
         *         if set as a classic comparator, it is used as comparator.
         *
         * @return true if the method encounter your conditions (number of times called), false otherwise
         */
        template <typename ComparatorOrContentChecker>
        bool verify(std::string methodName, ComparatorOrContentChecker &&coc) const {
            if constexpr (FSeam::isCalledComparator<ComparatorOrContentChecker>::v)
                return verify(std::move(methodName), [](std::any &methodCallVerifier) { return true; }, std::forward<ComparatorOrContentChecker>(coc));
            else if constexpr (std::is_integral<ComparatorOrContentChecker>())
                return verify(std::move(methodName), [](std::any &methodCallVerifier) { return true; }, VerifyCompare(coc));
            else
                return verify(std::move(methodName), std::forward<ComparatorOrContentChecker>(coc), AtLeast(1));
        }

        /**
         * @brief Verify if a method has been called under certain conditions (number of times)
         * 
         * @tparam ContentChecker Predicate type following this signature (bool (std::auto &methodCallVerifier))         
         * @tparam Comparator  comparator class used, those comparator are defined under the namespace FSeam::VerifierComparator, 
         *          VerifyCompare : Check if the method has been called exactly the number provided
         *          NeverCalled : Check if the method has never been called
         *          AtLeast : Check if the method has been called at least the number provided
         *          AtMost  : Check if the method has been called at most the number provided
         *          IsNot   : Check if the method is not the number provided
         *          
         * @param contentChecker this predicate will be used in order to check if the method has been called following
         *         specific predicament (std::auto containing metadata of call)
         * @param methodName Name of the method to check on the mock (Use the helpers constant to ensure no typo)
         * @param comp comparator instance on which the number of times the mock method is called on a provided value
         *         is checked against
         * @return true if the method encounter the provided comparator conditions, false otherwise
         */
        template <typename ContentChecker, typename Comparator>
        bool verify(std::string methodName, ContentChecker &&contentChecker, Comparator &&comp) const {
            std::string key = _className + std::move(methodName);

            if (_verifiers.find(key) == _verifiers.end()) {
                if (comp._toCompare > 0u) {
                    std::cout << "Verify error for method " << key << ", method never have been called while " 
                              << comp.expectStr(0u) << " method call \n";
                }
                return comp._toCompare == 0u;
            }
            auto mockMethodCalled = std::count_if(_verifiers.at(key)->_calledData.begin(), _verifiers.at(key)->_calledData.end(), contentChecker);
            bool result = comp.compare(mockMethodCalled);
            if (!result) {
                std::cout << "Verify error for method " << key << ", method has been called but "
                          << comp.expectStr(mockMethodCalled) << " method call following the specified contentChecker\n";
            }
            return result;
        }

    private:
        std::string _className;
        std::map<std::string, std::shared_ptr<MethodCallVerifier> > _verifiers;
    };

    /**
     * @brief Mocking singleton, this is the main class of FSeam class contains all the mock
     */
    class MockVerifier {
        inline static std::unique_ptr<MockVerifier> inst = nullptr;

    public:
        MockVerifier() = default;
        ~MockVerifier() = default;

        static MockVerifier &instance() {
            if (inst == nullptr) {
                inst = std::make_unique<MockVerifier>();
            };
            return *(inst.get());
        }

        /**
         * @brief Clean the FSeam context of all previously set mock behaviors
         */
        static void cleanUp() {
            inst.reset(nullptr);
        }

        bool isMockRegistered(const void *mockPtr) {
            return this->_mockedClass.find(mockPtr) != this->_mockedClass.end();
        }

        /**
         * @brief This method get the MockClassVerifier instance class
         * @details Method that retrieve the FSeam MockClassVerifier instance class corresponding to the pointer given as parameter
         *
         * @param mockPtr pointer on the instance to mock
         * @param classMockName name of the class to mock (provided by TypeParseTraits<>)
         * @return a MockClassVerifier shared_ptr class, if not referenced yet, create one by calling the ::addMock(T) method
         */
        std::shared_ptr<MockClassVerifier> &getMock(const void *mockPtr, const std::string &classMockName) {
            if (!isMockRegistered(mockPtr))
                return addMock(mockPtr, classMockName);
            return this->_mockedClass.at(mockPtr);
        }

        /**
         * @brief This method get the default MockClassVerifier for a class type
         * @details Method that retrieve the default MockClassVerifier instance class corresponding to type given as template parameter
         *
         * @param classMockName name of the class to mock (provided by TypeParseTraits<>)
         * @return a MockClassVerifier shared_ptr class, if not referenced yet, create one by calling the ::addDefaultMock(T) method
         */
        std::shared_ptr<MockClassVerifier> &getDefaultMock(const std::string &classMockName) {
            if (this->_defaultMockedClass.find(classMockName) == this->_defaultMockedClass.end())
                return addDefaultMock(classMockName);
            return this->_defaultMockedClass.at(classMockName);
        }

    private:
        std::shared_ptr<MockClassVerifier> &addMock(const void *mockPtr, const std::string &className) {
            this->_mockedClass[mockPtr] = std::make_shared<MockClassVerifier>(className);
            return this->_mockedClass.at(mockPtr);
        }
        std::shared_ptr<MockClassVerifier> &addDefaultMock(const std::string &className) {
            this->_defaultMockedClass[className] = std::make_shared<MockClassVerifier>(className);
            return this->_defaultMockedClass.at(className);
        }

    private:
        std::map<const void*, std::shared_ptr<MockClassVerifier> > _mockedClass;
        std::map<std::string, std::shared_ptr<MockClassVerifier> > _defaultMockedClass;
    };

    // ------------------------ Helper Client Free functions -------------------------- 

    /**
     * @brief This method get the MockClassVerifier instance class
     * @details Method that retrieve the mock verifier instance class corresponding to the pointer given as parameter
     *
     * @tparam T type of the instance to mock
     * @param mockPtr pointer on the instance to mock
     * @return the mock verifier instance class, if not referenced yet, create one by calling the ::addMock(T) method
     */
    template <typename T>
    std::shared_ptr<MockClassVerifier> &get(const T *mockPtr) {
        return FSeam::MockVerifier::instance().getMock(mockPtr, TypeParseTraits<T>::ClassName);
    }

    /**
     * @brief This method get the MockClassVerifier instance for the given class type
     * @details Get the Default MockClassVerifier correspond to the templated class
     *          This method has to be used in order to set default behaviors on a class type without needing to access
     *          the actual instance you want to mock
     *
     * @tparam T Class type that is going to be default mocked
     * @return std::shared_ptr<MockClassVerifier>& 
     */
    template <typename T>
    std::shared_ptr<MockClassVerifier> &getDefault() {
        return FSeam::MockVerifier::instance().getDefaultMock(TypeParseTraits<T>::ClassName);
    }

}

#endif //FREESOULS_MOCKVERIFIER_HH
