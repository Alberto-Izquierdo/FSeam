//
// Created by FyS on 27/06/17.
//

#ifndef FREESOULS_MOCKVERIFIER_HH
#define FREESOULS_MOCKVERIFIER_HH

#include <utility>
#include <string>
#include <functional>
#include <memory>
#include <iostream>
#include <map>
#include <any>

namespace FSeam {

    /**
     * @brief TypeTraitsClass with a ClassName alias in order to get the name of the class to mock (used as key for the methods)
     * @note The typetraits specifications are generated by FSeam generator
     * @tparam T type to mock
     */
    template <typename T>
    struct TypeParseTraits {
        static const std::string ClassName;
    };

    /**
     * @brief basic structure that contains description and usage metadata of a mocked method
     */
    struct MethodCallVerifier {
        std::string _methodName;
        std::size_t _called = 0;
        std::function<void(void*)> _handler;
        std::vector<std::any> _calledData;
    };

    /**
     * @brief Comparators option used in verify in order to give more flexibility into the check possible via te verify option
     */
    struct VerifyCompare {
        explicit VerifyCompare(uint toCompare) : _toCompare(toCompare) {}
        bool compare(uint number) { return _toCompare == number; } 
        std::string expectStr(uint number) { return std::string("we expected exactly ") +
            std::to_string(_toCompare) + std::string(" method call but received ") + std::to_string(number); };
        int _toCompare = 0;
    };
    struct NeverCalled {
        bool compare(uint number) { return !number; } 
        std::string expectStr(uint number) { return std::string("we expected this method to never be called ") +
            std::to_string(_toCompare) + std::string(" but received ") + std::to_string(number); };
        int _toCompare = 0;
    };
    struct AtLeast {
        explicit AtLeast(uint toCompare) : _toCompare(toCompare) {}
        bool compare(uint number) { return _toCompare <= number; }
        std::string expectStr(uint number) { return std::string("we expected at least ") +
            std::to_string(_toCompare) + std::string(" method call but received ") + std::to_string(number); };
        uint _toCompare = 0;
    };
    struct AtMost {
        explicit AtMost(uint toCompare) : _toCompare(toCompare) {}
        bool compare(uint number) { return _toCompare >= number; }
        std::string expectStr(uint number) { return std::string("we expected at most ") +
            std::to_string(_toCompare) + std::string(" method call but received ") + std::to_string(number); };
        uint _toCompare = 0;
    };
    struct IsNot { // Todo: Improve is not to take a list of params to check agains instead of a single value
        explicit IsNot(uint toCompare) : _toCompare(toCompare) {}
        bool compare(uint number) { return _toCompare != number; } 
        std::string expectStr(uint number) { return std::string("we expected other value than ") +
            std::to_string(_toCompare) + std::string(" method call but received ") + std::to_string(number); };
        uint _toCompare = 0;
    };

    template <typename TypeTraitClass>
    struct isComparator { static const bool v = false;  };
    template <> struct isComparator<IsNot> { static const bool v = true; };
    template <> struct isComparator<AtMost> { static const bool v = true; };
    template <> struct isComparator<AtLeast> { static const bool v = true; };
    template <> struct isComparator<NeverCalled> { static const bool v = true; };
    template <> struct isComparator<VerifyCompare> { static const bool v = true; };

    /**
     * @brief Mocking class, it contains all mocked method / save all calls to methods
     * @details A mock verifier instance class is a class that acknowledge all utilisation (method calls) of the mocked class
     *          this class also contains the mocked method (dupped).
     * @todo improve the mocking class to take the arguments and compare them in a verify
     */
    class MockClassVerifier {
    public:
        MockClassVerifier(std::string className) : _className(className) {}

        void invokeDupedMethod(std::string methodName, void *arg = nullptr) {
            std::string key = _className + std::move(methodName);

            if (_verifiers.find(key) != _verifiers.end()) {
                auto dupedMethod = _verifiers.at(std::move(key))->_handler;
                if (dupedMethod)
                    dupedMethod(arg);
            }
        }

        /**
         * @brief This method has to be called each time a mocked class is calling a method (in order to register the call)
         *
         * @param className name of the mocked class
         * @param methodName name of the method called
         */
        void methodCall(std::string methodName, std::any &&callingInfo) {
            std::shared_ptr<MethodCallVerifier> methodCallVerifier;
            std::string key = _className + methodName;

            if (_verifiers.find(key) != _verifiers.end())
                methodCallVerifier = _verifiers.at(key);
            else 
                methodCallVerifier = std::make_shared<MethodCallVerifier>();
            methodCallVerifier->_methodName = std::move(methodName);
            methodCallVerifier->_calledData.emplace_back(std::move(callingInfo));
            methodCallVerifier->_called = methodCallVerifier->_calledData.size();
            _verifiers[std::move(key)] = methodCallVerifier;
        }

        /**
         * @brief This method make it possible to dupe a method in order to have it do what you want.
         *
         * @param T handler type
         * @param className name of the class to mock
         * @param methodName method name to dupe
         * @param handler dupped method
         * @param isComposed if true, keep the current handler and add this new one as composition,
         *                   if false, override the existing handler if any
         *                   set at false by default
         */
        void dupeMethod(std::string methodName, std::function<void(void*)> handler, bool isComposed = false) {
            auto methodCallVerifier = std::make_shared<MethodCallVerifier>();
            std::string key = _className + methodName;

            if (_verifiers.find(key) != _verifiers.end())
                methodCallVerifier = _verifiers.at(key);
            methodCallVerifier->_methodName = std::move(methodName);
            methodCallVerifier->_calledData.clear();
            methodCallVerifier->_called = methodCallVerifier->_calledData.size();
            if (isComposed && methodCallVerifier->_handler) {
                methodCallVerifier->_handler = [currentHandler = methodCallVerifier->_handler, handler](void *data){
                    currentHandler(data);
                    handler(data);
                };
            }
            else
                methodCallVerifier->_handler = handler;
            _verifiers[std::move(key)] = methodCallVerifier;
        }


        /**
         * @brief verify if the given method has been at least called once
         * @details will call verify with a passthrough predicate and a AtLeast(1) comparator
         * @param methodName method to check
         * @return true if the method has been called at least once, false otherwise
         */
        bool verify(std::string methodName) const {
            return verify(std::move(methodName), [](std::any &methodCallVerifier) { return true; }, AtLeast(1));
        }

        /**
         * @brief Verify if a method has been called under certain conditions (number of times)
         * @note This method is going to call its templated overload using a default contentChecker (no check) and
         *       either FSeam::VerifierComparator::VerifyComparator or FSeam::VerifierComparator::AtLeast as Comparator
         *       depending on the value of times
         *
         * @tparam ComparatorOrContentChecker can be an integer/a comparator/a predicate see argument for additional info
         * @param methodName method to verify
         * @param compOrContentChecker can be an int or a predicate for the count
         *
         *        if set as a predicate it will be used in order to check if the method has been called following
         *         specific predicament (std::auto containing metadata of call) and check if atLeast(1) is found
         *        otherwhise a passthrough predicament is used (return true)
         *        =================
         *        if set with a positive integral value, check of times you verify that the mocked method has been called
         *         exactly the number of time provided (use the FSeam::VerifyComparator(compOrContentChecker)),
         *        if set as a classic comparator, it is used as comparator.
         *
         * @return true if the method encounter your conditions (number of times called), false otherwise
         */
        template <typename ComparatorOrContentChecker>
        bool verify(std::string methodName, ComparatorOrContentChecker &&compOrContentChecker) const {
            if constexpr (FSeam::isComparator<ComparatorOrContentChecker>::v)
                return verify(std::move(methodName), [](std::any &methodCallVerifier) { return true; }, compOrContentChecker);
            else if constexpr (std::is_integral<ComparatorOrContentChecker>())
                return verify(std::move(methodName), [](std::any &methodCallVerifier) { return true; }, VerifyCompare(compOrContentChecker));
            else
                return verify(std::move(methodName), std::forward<ComparatorOrContentChecker>(compOrContentChecker), AtLeast(1));
        }

        /**
         * @brief Verify if a method has been called under certain conditions (number of times)
         * 
         * @tparam ContentChecker Predicate type following this signature (bool (std::auto &methodCallVerifier))         
         * @tparam Comparator  comparator class used, those comparator are defined under the namespace FSeam::VerifierComparator, 
         *           AtLeast : Check if the method has been called at least the number provided
         *           AtMost  : Check if the method has been called at most the number provided
         *           IsNot   : Check if the method is not the number provided
         *          
         * @param contentChecker this predicate will be used in order to check if the method has been called following
         *         specific predicament (std::auto containing metadata of call)
         * @param methodName Name of the method to check on the mock (Use the helpers constant to ensure no typo)
         * @param comp comparator instance on which the number of times the mock method is called on a provided value
         *          is checked against
         * @return true if the method encounter the provided comparator conditions, false otherwise
         */
        template <typename ContentChecker, typename Comparator>
        bool verify(std::string methodName, ContentChecker &&contentChecker, Comparator &&comp) const {
            std::string key = _className + std::move(methodName);

            if (_verifiers.find(key) == _verifiers.end()) {
                if (comp._toCompare > 0u) {
                    std::cout << "Verify error for method " << key << ", method never have been called while " 
                              << comp.expectStr(0u) << " method call \n";
                }
                return comp._toCompare == 0u;
            }
            auto mockMethodCalled = std::count_if(_verifiers.at(key)->_calledData.begin(), _verifiers.at(key)->_calledData.end(), contentChecker);
            bool result = comp.compare(mockMethodCalled);
            if (!result) {
                std::cout << "Verify error for method " << key << ", method has been called but "
                          << comp.expectStr(mockMethodCalled) << " method call following the specified contentChecker\n";
            }
            return result;
        }

    private:
        std::string _className;
        std::map<std::string, std::shared_ptr<MethodCallVerifier> > _verifiers;
    };

    /**
     * @brief Mocking singleton, this is the main class of FSeam class contains all the mock
     */
    class MockVerifier {
        inline static std::unique_ptr<MockVerifier> inst = nullptr;

    public:
        MockVerifier() = default;
        ~MockVerifier() = default;

        static MockVerifier &instance() {
            if (inst == nullptr) {
                inst = std::make_unique<MockVerifier>();
            };
            return *(inst.get());
        }

        /**
         * @brief Clean the FSeam context of all previously set mock behaviors
         */
        static void cleanUp() {
            inst.reset(nullptr);
        }

        bool isMockRegistered(const void *mockPtr) {
            return this->_mockedClass.find(mockPtr) != this->_mockedClass.end();
        }

        /**
         * @brief This method get the mock verifier instance class
         *
         * @details Method that retrieve the mock verifier instance class corresponding to the pointer given as parameter
         *
         * @tparam T type to mock
         * @param mockPtr
         * @return the mock verifier instance class, if not referenced yet, create one by calling the ::addMock(T) method
         */
        template <typename T>
        std::shared_ptr<MockClassVerifier> &getMock(const T *mockPtr) {
            if (!isMockRegistered(mockPtr))
                return addMock(mockPtr);
            return this->_mockedClass.at(mockPtr);
        }

        /**
         * @brief This method get the default mock verifier for a class type
         *
         * @details Method that retrieve the mock default verifier instance class corresponding to type given as template parameter
         *
         * @tparam T type to mock
         * @param mockPtr
         * @return the mock verifier instance class, if not referenced yet, create one by calling the ::addMock(T) method
         */
        std::shared_ptr<MockClassVerifier> &getDefaultMock(std::string classMockName) {
            if (this->_defaultMockedClass.find(classMockName) == this->_defaultMockedClass.end())
                return addDefaultMock(classMockName);
            return this->_defaultMockedClass.at(std::move(classMockName));
        }

    private:
        template <typename T>
        std::shared_ptr<MockClassVerifier> &addMock(const T *mockPtr) {
            this->_mockedClass[mockPtr] = std::make_shared<MockClassVerifier>(TypeParseTraits<T>::ClassName);
            return this->_mockedClass.at(mockPtr);
        }
        std::shared_ptr<MockClassVerifier> &addDefaultMock(const std::string &className) {
            this->_defaultMockedClass[className] = std::make_shared<MockClassVerifier>(className);
            return this->_defaultMockedClass.at(className);
        }

    private:
        std::map<const void*, std::shared_ptr<MockClassVerifier> > _mockedClass;
        std::map<std::string, std::shared_ptr<MockClassVerifier> > _defaultMockedClass;
    };

    // ------------------------ Helper Client Free functions -------------------------- 

    /**
     * @brief This method get the mock verifier instance class
     *
     * @details Method that retrieve the mock verifier instance class corresponding to the pointer given as parameter

     *
     * @tparam T type to mock
     * @param mockPtr
     * @return the mock verifier instance class, if not referenced yet, create one by calling the ::addMock(T) method
     */
    template <typename T>
    std::shared_ptr<MockClassVerifier> &get(const T *mockPtr) {
        return FSeam::MockVerifier::instance().getMock(mockPtr);
    }

    /**
     * @details Get the Default MockClassVerifier correspond to the templated class
     *          This method has to be used in order to 
     * 
     * @tparam T 
     * @return std::shared_ptr<MockClassVerifier>& 
     */
    template <typename T>
    std::shared_ptr<MockClassVerifier> &getDefault() {
        return FSeam::MockVerifier::instance().getDefaultMock(TypeParseTraits<T>::ClassName);
    }

}

#endif //FREESOULS_MOCKVERIFIER_HH
